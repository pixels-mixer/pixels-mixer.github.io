<!DOCTYPE html>
<html>
	<head>
		<title>PIXELS MIXER</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Bangers&family=Doto:wght@100..900&family=Londrina+Shadow&display=swap" rel="stylesheet">
		<style>
			body {
				margin: 0;
				background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
				color: #000;
				overflow: hidden;
			}
			a {
				color: #48f;
			}
			#info {
				color: rgba(255,255,255,0.7);
				font-family: 'Doto', sans-serif;
				font-size: 32px;
				font-weight: 700;
				letter-spacing: 3px;
				text-transform: uppercase;
			}
			@media (max-width: 768px) {
				#info {
					font-size: 24px;
				}
			}
		</style>
	</head>
	<body>

		<div id="info">PIXELS MIXER</div>
		<div id="container"></div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import TWEEN from 'three/addons/libs/tween.module.js';
			import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
			import { CSS3DRenderer, CSS3DSprite } from 'three/addons/renderers/CSS3DRenderer.js';

			let camera, scene, renderer;
			let controls;
			let currentShape = 0;

			const particlesTotal = 512;
			const positions = [];
			const objects = [];
			let current = 0;

			// Add text container
			const textContainer = document.createElement('a');
			textContainer.target = '_blank';
			textContainer.rel = 'noopener noreferrer';
			textContainer.style.position = 'absolute';
			textContainer.style.color = 'white';
			textContainer.style.fontFamily = "'Londrina Shadow', cursive";
			textContainer.style.fontSize = 'min(4vw, 36px)'; // Responsive font size
			textContainer.style.fontWeight = 'bold';
			textContainer.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
			textContainer.style.opacity = '0';
			textContainer.style.transition = 'opacity 1s, transform 0.3s';
			textContainer.style.textDecoration = 'none';
			textContainer.style.cursor = 'pointer';
			textContainer.onmouseover = function() {
				const currentTransform = this.style.transform;
				this.style.transform = currentTransform + ' scale(2)';
			};
			textContainer.onmouseout = function() {
				const currentTransform = this.style.transform;
				this.style.transform = currentTransform.replace(' scale(2)', '');
			};
			document.body.appendChild(textContainer);

			// Function to update text size based on screen size
			function updateTextSize() {
				const isMobile = window.innerWidth <= 768;
				textContainer.style.fontSize = isMobile ? 'min(6vw, 24px)' : 'min(4vw, 36px)';
			}

			// Initial call and add resize listener
			updateTextSize();
			window.addEventListener('resize', updateTextSize);

			// Define texts and their positions for each shape
			const shapeTexts = [
				{ 
					text: 'Buy Me a Coffee ðŸ’› ðŸ’™', 
					position: { top: '35%', left: '70%', transform: 'translate(-50%, -50%)' },
					link: 'https://buymeacoffee.com/pixelsmixer'
				},  // Plane
				{ 
					text: 'Superhivemarket', 
					position: { top: '50%', left: '20%', transform: 'translateY(-50%)' },
					link: 'https://superhivemarket.com/creators/pixels-mixer'
				},  // Cube
				{ 
					text: 'Youtube', 
					position: { top: '50%', left: '80%', transform: 'translate(-50%, -50%)' },
					link: 'https://www.youtube.com/@pixels-mixer'
				},  // Random
				{ 
					text: 'Facebook', 
					position: { top: '25%', left: '50%', transform: 'translateX(-50%)' },
					link: 'https://www.facebook.com/pixelsmixer'
				},  // Sphere
				{ 
					text: 'Patreon', 
					position: { top: '50%', left: '50%', transform: 'translate(-50%, -50%)' },
					link: 'https://www.patreon.com/pixelsmixer'
				}  // Cylinder
			];

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );
				camera.position.set( 600, 400, 1500 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();

				const image = document.createElement( 'img' );
				image.addEventListener( 'load', function () {

					for ( let i = 0; i < particlesTotal; i ++ ) {

						const object = new CSS3DSprite( image.cloneNode() );
						object.position.x = Math.random() * 4000 - 2000,
						object.position.y = Math.random() * 4000 - 2000,
						object.position.z = Math.random() * 4000 - 2000;
						scene.add( object );

						objects.push( object );

					}

					transition();

				} );
				image.src = 'textures/sprite.png';

				// Plane

				const amountX = 16;
				const amountZ = 32;
				const separationPlane = 150;
				const offsetX = ( ( amountX - 1 ) * separationPlane ) / 2;
				const offsetZ = ( ( amountZ - 1 ) * separationPlane ) / 2;

				for ( let i = 0; i < particlesTotal; i ++ ) {

					const x = ( i % amountX ) * separationPlane;
					const z = Math.floor( i / amountX ) * separationPlane;
					const y = ( Math.sin( x * 0.5 ) + Math.sin( z * 0.5 ) ) * 200;

					positions.push( x - offsetX, y, z - offsetZ );

				}

				// Cube

				const amount = 8;
				const separationCube = 150;
				const offset = ( ( amount - 1 ) * separationCube ) / 2;

				for ( let i = 0; i < particlesTotal; i ++ ) {

					const x = ( i % amount ) * separationCube;
					const y = Math.floor( ( i / amount ) % amount ) * separationCube;
					const z = Math.floor( i / ( amount * amount ) ) * separationCube;

					positions.push( x - offset, y - offset, z - offset );

				}

				// Random

				for ( let i = 0; i < particlesTotal; i ++ ) {

					positions.push(
						Math.random() * 4000 - 2000,
						Math.random() * 4000 - 2000,
						Math.random() * 4000 - 2000
					);

				}

				// Sphere

				const radius = 750;

				for ( let i = 0; i < particlesTotal; i ++ ) {

					const phi = Math.acos( - 1 + ( 2 * i ) / particlesTotal );
					const theta = Math.sqrt( particlesTotal * Math.PI ) * phi;

					positions.push(
						radius * Math.cos( theta ) * Math.sin( phi ),
						radius * Math.sin( theta ) * Math.sin( phi ),
						radius * Math.cos( phi )
					);

				}

				// Cylinder

				const cylinderRadius = 500;
				const cylinderHeight = 1000;
				const cylinderSegments = 32;

				for ( let i = 0; i < particlesTotal; i ++ ) {
					const segment = i % cylinderSegments;
					const height = Math.floor(i / cylinderSegments) * (cylinderHeight / (particlesTotal / cylinderSegments)) - cylinderHeight/2;
					
					const angle = (segment / cylinderSegments) * Math.PI * 2;
					
					positions.push(
						cylinderRadius * Math.cos(angle),
						height,
						cylinderRadius * Math.sin(angle)
					);
				}

				//

				renderer = new CSS3DRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.getElementById( 'container' ).appendChild( renderer.domElement );

				//

				controls = new TrackballControls( camera, renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize );
				window.addEventListener( 'click', changeShape );

			}

			function changeShape() {
				currentShape = (currentShape + 1) % 5;
				const offset = currentShape * particlesTotal * 3;
				const duration = 2000;

				// Update and animate text
				textContainer.style.opacity = '0';
				setTimeout(() => {
					textContainer.textContent = shapeTexts[currentShape].text;
					// Apply new position
					Object.assign(textContainer.style, shapeTexts[currentShape].position);
					// Update link if exists
					if (shapeTexts[currentShape].link) {
						textContainer.href = shapeTexts[currentShape].link;
					} else {
						textContainer.href = '#';
					}
					textContainer.style.opacity = '1';
				}, 500);

				// Define camera positions for each shape
				const cameraPositions = [
					{ x: 1200, y: 800, z: 3000 },  // Plane - default view (increased distance)
					{ x: 2000, y: 1600, z: 1600 }, // Cube - diagonal view (increased distance)
					{ x: 0, y: 0, z: 4000 },       // Random - front view (increased distance)
					{ x: 3000, y: 0, z: 0 },       // Sphere - side view (increased distance)
					{ x: 0, y: 3000, z: 0 }        // Cylinder - top view (increased distance)
				];

				// Animate camera position
				new TWEEN.Tween(camera.position)
					.to(cameraPositions[currentShape], duration)
					.easing(TWEEN.Easing.Exponential.InOut)
					.start();

				// Animate camera lookAt
				new TWEEN.Tween(camera)
					.to({}, duration)
					.onUpdate(() => {
						camera.lookAt(0, 0, 0);
					})
					.start();

				// Animate sprites
				for ( let i = 0, j = offset; i < particlesTotal; i ++, j += 3 ) {
					const object = objects[ i ];
					new TWEEN.Tween( object.position )
						.to( {
							x: positions[ j ],
							y: positions[ j + 1 ],
							z: positions[ j + 2 ]
						}, Math.random() * duration + duration )
						.easing( TWEEN.Easing.Exponential.InOut )
						.start();
				}
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				TWEEN.update();
				controls.update();

				const time = performance.now();

				for ( let i = 0, l = objects.length; i < l; i ++ ) {

					const object = objects[ i ];
					const scale = Math.sin( ( Math.floor( object.position.x ) + time ) * 0.002 ) * 0.3 + 1;
					object.scale.set( scale, scale, scale );

				}

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>